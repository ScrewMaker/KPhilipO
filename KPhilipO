local rep = cloneref(game:GetService("ReplicatedStorage"))
local ogmod = rep.Shared.entities.Player.Model

local oldindex1
oldindex1 = hookmetamethod(game, "__index", newcclosure(function(self, index)
    if not checkcaller() and (index == "CanCollide" or index == "Transparency" or index == "Size") and (self.Name == "Torso" or self.Name == "Head") then
        return ogmod[self.Name][index]
    end
    return oldindex1(self,index)
end))

local char = {}
local h = { enabled = true, sizeX = 14, sizeY = 14, sizeZ = 14 }
local maxSize = 50
local processedCache = {}

function char:updatehitbox()
    for _, v in pairs(PlayerList) do
        if not processedCache[v] then
            if v.type == "Player" and v.model:FindFirstChild("HumanoidRootPart") and not v.sleeping then
                local t = v.model:FindFirstChild("Torso")
                if t then
                    t.Size = h.enabled and Vector3.new(h.sizeX, h.sizeY, h.sizeZ) or Vector3.new(0.6530659198760986, 2.220424175262451, 1.4367451667785645)
                    t.CanCollide = false
                    t.Transparency = h.enabled and 0.8 or 0
                end
                processedCache[v] = true
            end
        end
    end
end

local function checkSizes()
    local naughty = false
    if h.sizeX > maxSize then
        h.sizeX = maxSize
        naughty = true
    end
    if h.sizeY > maxSize then
        h.sizeY = maxSize
        naughty = true
    end
    if h.sizeZ > maxSize then
        h.sizeZ = maxSize
        naughty = true
    end
    if naughty then
        local Player = game:GetService("Players").LocalPlayer
        -- Uncomment to kick player if they exceed size limits
        -- Player:Kick("Reason Expected You Overrided A Check In Script")
    end
end

workspace.ChildAdded:Connect(function(v)
    task.delay(1, function()
        if v:FindFirstChild("Head") and v:FindFirstChild("Torso") then
            processedCache[v] = nil
            char:updatehitbox()
        end
    end)
end)

game:GetService("Players").PlayerRemoving:Connect(function(player)
    for _, v in pairs(PlayerList) do
        if v == player then
            processedCache[v] = nil
        end
    end
end)

game:GetService("Players").PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(character)
        task.delay(1, function()
            -- Handle new player character after it appears
            if character:FindFirstChild("Torso") then
                processedCache[player] = nil
                char:updatehitbox()
            end
        end)
    end)
end)

-- Function to toggle hitbox
local function toggleHitbox(state)
    h.enabled = state
    char:updatehitbox()
end

-- Function to update hitbox size
local function updateHitboxSize(x, y, z)
    h.sizeX = x
    h.sizeY = y
    h.sizeZ = z
    checkSizes()
    char:updatehitbox()
end

-- Function to update transparency
local function updateTransparency(value)
    for _, v in pairs(PlayerList) do
        local t = v.model.Torso
        if t then
            t.Transparency = value
        end
    end
end

local hitboxOverrider = true

local function generateScaleFactors()
    local scaleFactors = {}
    local baseScales = {0.008, 0.009, 0.008}
    local decrement = 0.0003

    for pitch = 30, -10, -5 do
        local scales = {}
        if pitch >= 0 then
            scales = {baseScales[1] - (30 - pitch) * decrement, baseScales[2] - (30 - pitch) * decrement, baseScales[3] - (30 - pitch) * decrement}
        else
            scales = {baseScales[1] - (30 + pitch) * decrement, baseScales[2] - (30 + pitch) * decrement, baseScales[3] - (30 + pitch) * decrement}
        end
        table.insert(scaleFactors, {threshold = pitch, scales = scales})
    end

    table.insert(scaleFactors, {threshold = -math.huge, scales = {0.006, 0.005, 0.006}})

    return scaleFactors
end

local scaleFactors = generateScaleFactors()

function char:GenVector(targetPos)
    local direction = (targetPos - Camera.CFrame.Position).unit
    local lookDirection = Camera.CFrame.LookVector

    local pitch = math.deg(math.asin(lookDirection.Y))

    local scaleValues = {0, 0, 0}

    for _, entry in ipairs(scaleFactors) do
        if pitch > entry.threshold then
            scaleValues = entry.scales
            break
        end
    end

    local magnitude = (targetPos - Camera.CFrame.Position).Magnitude

    return Vector3.new(
        direction.X * (magnitude * scaleValues[1]),
        direction.Y * (magnitude * scaleValues[2]),
        direction.Z * (magnitude * scaleValues[3])
    )
end

local mt = getrawmetatable(game)
setreadonly(mt, false)

local oldIndex = mt.__namecall
mt.__namecall = function(...)
    local method = getnamecallmethod()
    local args = {...}

    if method == "FireServer" then
        local eventId, eventType, hitPart = args[2], args[3], args[7]

        if eventId == 10 and eventType == "Hit" and (hitPart == "Torso" or hitPart == "Head") then
            local genVector = char:GenVector(args[9])
            args[8] = Vector3.new(genVector.X, genVector.Y, genVector.Z)
        end
    end

    return oldIndex(table.unpack(args))
end

local meta = getrawmetatable(game)
setreadonly(meta, false)

local oldIndex = meta.__namecall
meta.__namecall = function(...)
    local method = getnamecallmethod()
    local args = {...}

    -- Debugging logs
    print("Namecall method:", method)
    print("Arguments:", table.unpack(args))

    if args[2] == 10 and args[3] == "Hit" and args[7] == "Torso" and hitboxOverrider then
        print("Overriding hitbox part from Torso to Head")
        args[7] = "Head"
    end

    return oldIndex(table.unpack(args))
end

setreadonly(meta, true)
